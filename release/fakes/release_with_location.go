// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/kiln/release"
)

type ReleaseWithLocation struct {
	LocalPathStub        func() string
	localPathMutex       sync.RWMutex
	localPathArgsForCall []struct {
	}
	localPathReturns struct {
		result1 string
	}
	localPathReturnsOnCall map[int]struct {
		result1 string
	}
	ReleaseIDStub        func() release.ReleaseID
	releaseIDMutex       sync.RWMutex
	releaseIDArgsForCall []struct {
	}
	releaseIDReturns struct {
		result1 release.ReleaseID
	}
	releaseIDReturnsOnCall map[int]struct {
		result1 release.ReleaseID
	}
	RemotePathStub        func() string
	remotePathMutex       sync.RWMutex
	remotePathArgsForCall []struct {
	}
	remotePathReturns struct {
		result1 string
	}
	remotePathReturnsOnCall map[int]struct {
		result1 string
	}
	SatisfiesStub        func(release.ReleaseRequirement) bool
	satisfiesMutex       sync.RWMutex
	satisfiesArgsForCall []struct {
		arg1 release.ReleaseRequirement
	}
	satisfiesReturns struct {
		result1 bool
	}
	satisfiesReturnsOnCall map[int]struct {
		result1 bool
	}
	StandardizedFilenameStub        func() string
	standardizedFilenameMutex       sync.RWMutex
	standardizedFilenameArgsForCall []struct {
	}
	standardizedFilenameReturns struct {
		result1 string
	}
	standardizedFilenameReturnsOnCall map[int]struct {
		result1 string
	}
	WithLocalPathStub        func(string) release.ReleaseWithLocation
	withLocalPathMutex       sync.RWMutex
	withLocalPathArgsForCall []struct {
		arg1 string
	}
	withLocalPathReturns struct {
		result1 release.ReleaseWithLocation
	}
	withLocalPathReturnsOnCall map[int]struct {
		result1 release.ReleaseWithLocation
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ReleaseWithLocation) LocalPath() string {
	fake.localPathMutex.Lock()
	ret, specificReturn := fake.localPathReturnsOnCall[len(fake.localPathArgsForCall)]
	fake.localPathArgsForCall = append(fake.localPathArgsForCall, struct {
	}{})
	fake.recordInvocation("LocalPath", []interface{}{})
	fake.localPathMutex.Unlock()
	if fake.LocalPathStub != nil {
		return fake.LocalPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localPathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) LocalPathCallCount() int {
	fake.localPathMutex.RLock()
	defer fake.localPathMutex.RUnlock()
	return len(fake.localPathArgsForCall)
}

func (fake *ReleaseWithLocation) LocalPathCalls(stub func() string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = stub
}

func (fake *ReleaseWithLocation) LocalPathReturns(result1 string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = nil
	fake.localPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) LocalPathReturnsOnCall(i int, result1 string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = nil
	if fake.localPathReturnsOnCall == nil {
		fake.localPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseID() release.ReleaseID {
	fake.releaseIDMutex.Lock()
	ret, specificReturn := fake.releaseIDReturnsOnCall[len(fake.releaseIDArgsForCall)]
	fake.releaseIDArgsForCall = append(fake.releaseIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ReleaseID", []interface{}{})
	fake.releaseIDMutex.Unlock()
	if fake.ReleaseIDStub != nil {
		return fake.ReleaseIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.releaseIDReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) ReleaseIDCallCount() int {
	fake.releaseIDMutex.RLock()
	defer fake.releaseIDMutex.RUnlock()
	return len(fake.releaseIDArgsForCall)
}

func (fake *ReleaseWithLocation) ReleaseIDCalls(stub func() release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = stub
}

func (fake *ReleaseWithLocation) ReleaseIDReturns(result1 release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = nil
	fake.releaseIDReturns = struct {
		result1 release.ReleaseID
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseIDReturnsOnCall(i int, result1 release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = nil
	if fake.releaseIDReturnsOnCall == nil {
		fake.releaseIDReturnsOnCall = make(map[int]struct {
			result1 release.ReleaseID
		})
	}
	fake.releaseIDReturnsOnCall[i] = struct {
		result1 release.ReleaseID
	}{result1}
}

func (fake *ReleaseWithLocation) RemotePath() string {
	fake.remotePathMutex.Lock()
	ret, specificReturn := fake.remotePathReturnsOnCall[len(fake.remotePathArgsForCall)]
	fake.remotePathArgsForCall = append(fake.remotePathArgsForCall, struct {
	}{})
	fake.recordInvocation("RemotePath", []interface{}{})
	fake.remotePathMutex.Unlock()
	if fake.RemotePathStub != nil {
		return fake.RemotePathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.remotePathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) RemotePathCallCount() int {
	fake.remotePathMutex.RLock()
	defer fake.remotePathMutex.RUnlock()
	return len(fake.remotePathArgsForCall)
}

func (fake *ReleaseWithLocation) RemotePathCalls(stub func() string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = stub
}

func (fake *ReleaseWithLocation) RemotePathReturns(result1 string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = nil
	fake.remotePathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) RemotePathReturnsOnCall(i int, result1 string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = nil
	if fake.remotePathReturnsOnCall == nil {
		fake.remotePathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.remotePathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) Satisfies(arg1 release.ReleaseRequirement) bool {
	fake.satisfiesMutex.Lock()
	ret, specificReturn := fake.satisfiesReturnsOnCall[len(fake.satisfiesArgsForCall)]
	fake.satisfiesArgsForCall = append(fake.satisfiesArgsForCall, struct {
		arg1 release.ReleaseRequirement
	}{arg1})
	fake.recordInvocation("Satisfies", []interface{}{arg1})
	fake.satisfiesMutex.Unlock()
	if fake.SatisfiesStub != nil {
		return fake.SatisfiesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.satisfiesReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) SatisfiesCallCount() int {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	return len(fake.satisfiesArgsForCall)
}

func (fake *ReleaseWithLocation) SatisfiesCalls(stub func(release.ReleaseRequirement) bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = stub
}

func (fake *ReleaseWithLocation) SatisfiesArgsForCall(i int) release.ReleaseRequirement {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	argsForCall := fake.satisfiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ReleaseWithLocation) SatisfiesReturns(result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	fake.satisfiesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ReleaseWithLocation) SatisfiesReturnsOnCall(i int, result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	if fake.satisfiesReturnsOnCall == nil {
		fake.satisfiesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.satisfiesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ReleaseWithLocation) StandardizedFilename() string {
	fake.standardizedFilenameMutex.Lock()
	ret, specificReturn := fake.standardizedFilenameReturnsOnCall[len(fake.standardizedFilenameArgsForCall)]
	fake.standardizedFilenameArgsForCall = append(fake.standardizedFilenameArgsForCall, struct {
	}{})
	fake.recordInvocation("StandardizedFilename", []interface{}{})
	fake.standardizedFilenameMutex.Unlock()
	if fake.StandardizedFilenameStub != nil {
		return fake.StandardizedFilenameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.standardizedFilenameReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) StandardizedFilenameCallCount() int {
	fake.standardizedFilenameMutex.RLock()
	defer fake.standardizedFilenameMutex.RUnlock()
	return len(fake.standardizedFilenameArgsForCall)
}

func (fake *ReleaseWithLocation) StandardizedFilenameCalls(stub func() string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = stub
}

func (fake *ReleaseWithLocation) StandardizedFilenameReturns(result1 string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = nil
	fake.standardizedFilenameReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) StandardizedFilenameReturnsOnCall(i int, result1 string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = nil
	if fake.standardizedFilenameReturnsOnCall == nil {
		fake.standardizedFilenameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.standardizedFilenameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) WithLocalPath(arg1 string) release.ReleaseWithLocation {
	fake.withLocalPathMutex.Lock()
	ret, specificReturn := fake.withLocalPathReturnsOnCall[len(fake.withLocalPathArgsForCall)]
	fake.withLocalPathArgsForCall = append(fake.withLocalPathArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WithLocalPath", []interface{}{arg1})
	fake.withLocalPathMutex.Unlock()
	if fake.WithLocalPathStub != nil {
		return fake.WithLocalPathStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withLocalPathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) WithLocalPathCallCount() int {
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	return len(fake.withLocalPathArgsForCall)
}

func (fake *ReleaseWithLocation) WithLocalPathCalls(stub func(string) release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = stub
}

func (fake *ReleaseWithLocation) WithLocalPathArgsForCall(i int) string {
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	argsForCall := fake.withLocalPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ReleaseWithLocation) WithLocalPathReturns(result1 release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = nil
	fake.withLocalPathReturns = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) WithLocalPathReturnsOnCall(i int, result1 release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = nil
	if fake.withLocalPathReturnsOnCall == nil {
		fake.withLocalPathReturnsOnCall = make(map[int]struct {
			result1 release.ReleaseWithLocation
		})
	}
	fake.withLocalPathReturnsOnCall[i] = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.localPathMutex.RLock()
	defer fake.localPathMutex.RUnlock()
	fake.releaseIDMutex.RLock()
	defer fake.releaseIDMutex.RUnlock()
	fake.remotePathMutex.RLock()
	defer fake.remotePathMutex.RUnlock()
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	fake.standardizedFilenameMutex.RLock()
	defer fake.standardizedFilenameMutex.RUnlock()
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ReleaseWithLocation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ release.ReleaseWithLocation = new(ReleaseWithLocation)
