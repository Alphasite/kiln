// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/kiln/release"
)

type ReleaseWithLocation struct {
	AsLocalReleaseStub        func(string) release.LocalRelease
	asLocalReleaseMutex       sync.RWMutex
	asLocalReleaseArgsForCall []struct {
		arg1 string
	}
	asLocalReleaseReturns struct {
		result1 release.LocalRelease
	}
	asLocalReleaseReturnsOnCall map[int]struct {
		result1 release.LocalRelease
	}
	LocalPathStub        func() string
	localPathMutex       sync.RWMutex
	localPathArgsForCall []struct {
	}
	localPathReturns struct {
		result1 string
	}
	localPathReturnsOnCall map[int]struct {
		result1 string
	}
	ReleaseIDStub        func() release.ReleaseID
	releaseIDMutex       sync.RWMutex
	releaseIDArgsForCall []struct {
	}
	releaseIDReturns struct {
		result1 release.ReleaseID
	}
	releaseIDReturnsOnCall map[int]struct {
		result1 release.ReleaseID
	}
	ReleaseSourceIDStub        func() string
	releaseSourceIDMutex       sync.RWMutex
	releaseSourceIDArgsForCall []struct {
	}
	releaseSourceIDReturns struct {
		result1 string
	}
	releaseSourceIDReturnsOnCall map[int]struct {
		result1 string
	}
	RemotePathStub        func() string
	remotePathMutex       sync.RWMutex
	remotePathArgsForCall []struct {
	}
	remotePathReturns struct {
		result1 string
	}
	remotePathReturnsOnCall map[int]struct {
		result1 string
	}
	SatisfiesStub        func(release.ReleaseRequirement) bool
	satisfiesMutex       sync.RWMutex
	satisfiesArgsForCall []struct {
		arg1 release.ReleaseRequirement
	}
	satisfiesReturns struct {
		result1 bool
	}
	satisfiesReturnsOnCall map[int]struct {
		result1 bool
	}
	StandardizedFilenameStub        func() string
	standardizedFilenameMutex       sync.RWMutex
	standardizedFilenameArgsForCall []struct {
	}
	standardizedFilenameReturns struct {
		result1 string
	}
	standardizedFilenameReturnsOnCall map[int]struct {
		result1 string
	}
	WithLocalPathStub        func(string) release.ReleaseWithLocation
	withLocalPathMutex       sync.RWMutex
	withLocalPathArgsForCall []struct {
		arg1 string
	}
	withLocalPathReturns struct {
		result1 release.ReleaseWithLocation
	}
	withLocalPathReturnsOnCall map[int]struct {
		result1 release.ReleaseWithLocation
	}
	WithRemoteStub        func(string, string) release.ReleaseWithLocation
	withRemoteMutex       sync.RWMutex
	withRemoteArgsForCall []struct {
		arg1 string
		arg2 string
	}
	withRemoteReturns struct {
		result1 release.ReleaseWithLocation
	}
	withRemoteReturnsOnCall map[int]struct {
		result1 release.ReleaseWithLocation
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ReleaseWithLocation) AsLocalRelease(arg1 string) release.LocalRelease {
	fake.asLocalReleaseMutex.Lock()
	ret, specificReturn := fake.asLocalReleaseReturnsOnCall[len(fake.asLocalReleaseArgsForCall)]
	fake.asLocalReleaseArgsForCall = append(fake.asLocalReleaseArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AsLocalRelease", []interface{}{arg1})
	fake.asLocalReleaseMutex.Unlock()
	if fake.AsLocalReleaseStub != nil {
		return fake.AsLocalReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.asLocalReleaseReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) AsLocalReleaseCallCount() int {
	fake.asLocalReleaseMutex.RLock()
	defer fake.asLocalReleaseMutex.RUnlock()
	return len(fake.asLocalReleaseArgsForCall)
}

func (fake *ReleaseWithLocation) AsLocalReleaseCalls(stub func(string) release.LocalRelease) {
	fake.asLocalReleaseMutex.Lock()
	defer fake.asLocalReleaseMutex.Unlock()
	fake.AsLocalReleaseStub = stub
}

func (fake *ReleaseWithLocation) AsLocalReleaseArgsForCall(i int) string {
	fake.asLocalReleaseMutex.RLock()
	defer fake.asLocalReleaseMutex.RUnlock()
	argsForCall := fake.asLocalReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ReleaseWithLocation) AsLocalReleaseReturns(result1 release.LocalRelease) {
	fake.asLocalReleaseMutex.Lock()
	defer fake.asLocalReleaseMutex.Unlock()
	fake.AsLocalReleaseStub = nil
	fake.asLocalReleaseReturns = struct {
		result1 release.LocalRelease
	}{result1}
}

func (fake *ReleaseWithLocation) AsLocalReleaseReturnsOnCall(i int, result1 release.LocalRelease) {
	fake.asLocalReleaseMutex.Lock()
	defer fake.asLocalReleaseMutex.Unlock()
	fake.AsLocalReleaseStub = nil
	if fake.asLocalReleaseReturnsOnCall == nil {
		fake.asLocalReleaseReturnsOnCall = make(map[int]struct {
			result1 release.LocalRelease
		})
	}
	fake.asLocalReleaseReturnsOnCall[i] = struct {
		result1 release.LocalRelease
	}{result1}
}

func (fake *ReleaseWithLocation) LocalPath() string {
	fake.localPathMutex.Lock()
	ret, specificReturn := fake.localPathReturnsOnCall[len(fake.localPathArgsForCall)]
	fake.localPathArgsForCall = append(fake.localPathArgsForCall, struct {
	}{})
	fake.recordInvocation("LocalPath", []interface{}{})
	fake.localPathMutex.Unlock()
	if fake.LocalPathStub != nil {
		return fake.LocalPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localPathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) LocalPathCallCount() int {
	fake.localPathMutex.RLock()
	defer fake.localPathMutex.RUnlock()
	return len(fake.localPathArgsForCall)
}

func (fake *ReleaseWithLocation) LocalPathCalls(stub func() string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = stub
}

func (fake *ReleaseWithLocation) LocalPathReturns(result1 string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = nil
	fake.localPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) LocalPathReturnsOnCall(i int, result1 string) {
	fake.localPathMutex.Lock()
	defer fake.localPathMutex.Unlock()
	fake.LocalPathStub = nil
	if fake.localPathReturnsOnCall == nil {
		fake.localPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseID() release.ReleaseID {
	fake.releaseIDMutex.Lock()
	ret, specificReturn := fake.releaseIDReturnsOnCall[len(fake.releaseIDArgsForCall)]
	fake.releaseIDArgsForCall = append(fake.releaseIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ReleaseID", []interface{}{})
	fake.releaseIDMutex.Unlock()
	if fake.ReleaseIDStub != nil {
		return fake.ReleaseIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.releaseIDReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) ReleaseIDCallCount() int {
	fake.releaseIDMutex.RLock()
	defer fake.releaseIDMutex.RUnlock()
	return len(fake.releaseIDArgsForCall)
}

func (fake *ReleaseWithLocation) ReleaseIDCalls(stub func() release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = stub
}

func (fake *ReleaseWithLocation) ReleaseIDReturns(result1 release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = nil
	fake.releaseIDReturns = struct {
		result1 release.ReleaseID
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseIDReturnsOnCall(i int, result1 release.ReleaseID) {
	fake.releaseIDMutex.Lock()
	defer fake.releaseIDMutex.Unlock()
	fake.ReleaseIDStub = nil
	if fake.releaseIDReturnsOnCall == nil {
		fake.releaseIDReturnsOnCall = make(map[int]struct {
			result1 release.ReleaseID
		})
	}
	fake.releaseIDReturnsOnCall[i] = struct {
		result1 release.ReleaseID
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseSourceID() string {
	fake.releaseSourceIDMutex.Lock()
	ret, specificReturn := fake.releaseSourceIDReturnsOnCall[len(fake.releaseSourceIDArgsForCall)]
	fake.releaseSourceIDArgsForCall = append(fake.releaseSourceIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ReleaseSourceID", []interface{}{})
	fake.releaseSourceIDMutex.Unlock()
	if fake.ReleaseSourceIDStub != nil {
		return fake.ReleaseSourceIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.releaseSourceIDReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) ReleaseSourceIDCallCount() int {
	fake.releaseSourceIDMutex.RLock()
	defer fake.releaseSourceIDMutex.RUnlock()
	return len(fake.releaseSourceIDArgsForCall)
}

func (fake *ReleaseWithLocation) ReleaseSourceIDCalls(stub func() string) {
	fake.releaseSourceIDMutex.Lock()
	defer fake.releaseSourceIDMutex.Unlock()
	fake.ReleaseSourceIDStub = stub
}

func (fake *ReleaseWithLocation) ReleaseSourceIDReturns(result1 string) {
	fake.releaseSourceIDMutex.Lock()
	defer fake.releaseSourceIDMutex.Unlock()
	fake.ReleaseSourceIDStub = nil
	fake.releaseSourceIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) ReleaseSourceIDReturnsOnCall(i int, result1 string) {
	fake.releaseSourceIDMutex.Lock()
	defer fake.releaseSourceIDMutex.Unlock()
	fake.ReleaseSourceIDStub = nil
	if fake.releaseSourceIDReturnsOnCall == nil {
		fake.releaseSourceIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.releaseSourceIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) RemotePath() string {
	fake.remotePathMutex.Lock()
	ret, specificReturn := fake.remotePathReturnsOnCall[len(fake.remotePathArgsForCall)]
	fake.remotePathArgsForCall = append(fake.remotePathArgsForCall, struct {
	}{})
	fake.recordInvocation("RemotePath", []interface{}{})
	fake.remotePathMutex.Unlock()
	if fake.RemotePathStub != nil {
		return fake.RemotePathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.remotePathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) RemotePathCallCount() int {
	fake.remotePathMutex.RLock()
	defer fake.remotePathMutex.RUnlock()
	return len(fake.remotePathArgsForCall)
}

func (fake *ReleaseWithLocation) RemotePathCalls(stub func() string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = stub
}

func (fake *ReleaseWithLocation) RemotePathReturns(result1 string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = nil
	fake.remotePathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) RemotePathReturnsOnCall(i int, result1 string) {
	fake.remotePathMutex.Lock()
	defer fake.remotePathMutex.Unlock()
	fake.RemotePathStub = nil
	if fake.remotePathReturnsOnCall == nil {
		fake.remotePathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.remotePathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) Satisfies(arg1 release.ReleaseRequirement) bool {
	fake.satisfiesMutex.Lock()
	ret, specificReturn := fake.satisfiesReturnsOnCall[len(fake.satisfiesArgsForCall)]
	fake.satisfiesArgsForCall = append(fake.satisfiesArgsForCall, struct {
		arg1 release.ReleaseRequirement
	}{arg1})
	fake.recordInvocation("Satisfies", []interface{}{arg1})
	fake.satisfiesMutex.Unlock()
	if fake.SatisfiesStub != nil {
		return fake.SatisfiesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.satisfiesReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) SatisfiesCallCount() int {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	return len(fake.satisfiesArgsForCall)
}

func (fake *ReleaseWithLocation) SatisfiesCalls(stub func(release.ReleaseRequirement) bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = stub
}

func (fake *ReleaseWithLocation) SatisfiesArgsForCall(i int) release.ReleaseRequirement {
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	argsForCall := fake.satisfiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ReleaseWithLocation) SatisfiesReturns(result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	fake.satisfiesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ReleaseWithLocation) SatisfiesReturnsOnCall(i int, result1 bool) {
	fake.satisfiesMutex.Lock()
	defer fake.satisfiesMutex.Unlock()
	fake.SatisfiesStub = nil
	if fake.satisfiesReturnsOnCall == nil {
		fake.satisfiesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.satisfiesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ReleaseWithLocation) StandardizedFilename() string {
	fake.standardizedFilenameMutex.Lock()
	ret, specificReturn := fake.standardizedFilenameReturnsOnCall[len(fake.standardizedFilenameArgsForCall)]
	fake.standardizedFilenameArgsForCall = append(fake.standardizedFilenameArgsForCall, struct {
	}{})
	fake.recordInvocation("StandardizedFilename", []interface{}{})
	fake.standardizedFilenameMutex.Unlock()
	if fake.StandardizedFilenameStub != nil {
		return fake.StandardizedFilenameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.standardizedFilenameReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) StandardizedFilenameCallCount() int {
	fake.standardizedFilenameMutex.RLock()
	defer fake.standardizedFilenameMutex.RUnlock()
	return len(fake.standardizedFilenameArgsForCall)
}

func (fake *ReleaseWithLocation) StandardizedFilenameCalls(stub func() string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = stub
}

func (fake *ReleaseWithLocation) StandardizedFilenameReturns(result1 string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = nil
	fake.standardizedFilenameReturns = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) StandardizedFilenameReturnsOnCall(i int, result1 string) {
	fake.standardizedFilenameMutex.Lock()
	defer fake.standardizedFilenameMutex.Unlock()
	fake.StandardizedFilenameStub = nil
	if fake.standardizedFilenameReturnsOnCall == nil {
		fake.standardizedFilenameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.standardizedFilenameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ReleaseWithLocation) WithLocalPath(arg1 string) release.ReleaseWithLocation {
	fake.withLocalPathMutex.Lock()
	ret, specificReturn := fake.withLocalPathReturnsOnCall[len(fake.withLocalPathArgsForCall)]
	fake.withLocalPathArgsForCall = append(fake.withLocalPathArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WithLocalPath", []interface{}{arg1})
	fake.withLocalPathMutex.Unlock()
	if fake.WithLocalPathStub != nil {
		return fake.WithLocalPathStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withLocalPathReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) WithLocalPathCallCount() int {
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	return len(fake.withLocalPathArgsForCall)
}

func (fake *ReleaseWithLocation) WithLocalPathCalls(stub func(string) release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = stub
}

func (fake *ReleaseWithLocation) WithLocalPathArgsForCall(i int) string {
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	argsForCall := fake.withLocalPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ReleaseWithLocation) WithLocalPathReturns(result1 release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = nil
	fake.withLocalPathReturns = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) WithLocalPathReturnsOnCall(i int, result1 release.ReleaseWithLocation) {
	fake.withLocalPathMutex.Lock()
	defer fake.withLocalPathMutex.Unlock()
	fake.WithLocalPathStub = nil
	if fake.withLocalPathReturnsOnCall == nil {
		fake.withLocalPathReturnsOnCall = make(map[int]struct {
			result1 release.ReleaseWithLocation
		})
	}
	fake.withLocalPathReturnsOnCall[i] = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) WithRemote(arg1 string, arg2 string) release.ReleaseWithLocation {
	fake.withRemoteMutex.Lock()
	ret, specificReturn := fake.withRemoteReturnsOnCall[len(fake.withRemoteArgsForCall)]
	fake.withRemoteArgsForCall = append(fake.withRemoteArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WithRemote", []interface{}{arg1, arg2})
	fake.withRemoteMutex.Unlock()
	if fake.WithRemoteStub != nil {
		return fake.WithRemoteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withRemoteReturns
	return fakeReturns.result1
}

func (fake *ReleaseWithLocation) WithRemoteCallCount() int {
	fake.withRemoteMutex.RLock()
	defer fake.withRemoteMutex.RUnlock()
	return len(fake.withRemoteArgsForCall)
}

func (fake *ReleaseWithLocation) WithRemoteCalls(stub func(string, string) release.ReleaseWithLocation) {
	fake.withRemoteMutex.Lock()
	defer fake.withRemoteMutex.Unlock()
	fake.WithRemoteStub = stub
}

func (fake *ReleaseWithLocation) WithRemoteArgsForCall(i int) (string, string) {
	fake.withRemoteMutex.RLock()
	defer fake.withRemoteMutex.RUnlock()
	argsForCall := fake.withRemoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ReleaseWithLocation) WithRemoteReturns(result1 release.ReleaseWithLocation) {
	fake.withRemoteMutex.Lock()
	defer fake.withRemoteMutex.Unlock()
	fake.WithRemoteStub = nil
	fake.withRemoteReturns = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) WithRemoteReturnsOnCall(i int, result1 release.ReleaseWithLocation) {
	fake.withRemoteMutex.Lock()
	defer fake.withRemoteMutex.Unlock()
	fake.WithRemoteStub = nil
	if fake.withRemoteReturnsOnCall == nil {
		fake.withRemoteReturnsOnCall = make(map[int]struct {
			result1 release.ReleaseWithLocation
		})
	}
	fake.withRemoteReturnsOnCall[i] = struct {
		result1 release.ReleaseWithLocation
	}{result1}
}

func (fake *ReleaseWithLocation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.asLocalReleaseMutex.RLock()
	defer fake.asLocalReleaseMutex.RUnlock()
	fake.localPathMutex.RLock()
	defer fake.localPathMutex.RUnlock()
	fake.releaseIDMutex.RLock()
	defer fake.releaseIDMutex.RUnlock()
	fake.releaseSourceIDMutex.RLock()
	defer fake.releaseSourceIDMutex.RUnlock()
	fake.remotePathMutex.RLock()
	defer fake.remotePathMutex.RUnlock()
	fake.satisfiesMutex.RLock()
	defer fake.satisfiesMutex.RUnlock()
	fake.standardizedFilenameMutex.RLock()
	defer fake.standardizedFilenameMutex.RUnlock()
	fake.withLocalPathMutex.RLock()
	defer fake.withLocalPathMutex.RUnlock()
	fake.withRemoteMutex.RLock()
	defer fake.withRemoteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ReleaseWithLocation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ release.ReleaseWithLocation = new(ReleaseWithLocation)
